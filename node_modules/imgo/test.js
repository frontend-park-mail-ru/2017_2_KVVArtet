const fs = require('fs');

const pify = require('pify');
const test = require('ava');
const imgo = require('.');

const fsP = pify(fs);

test('should minify PNG images with pngquant', async t => {
  const buffer = await fsP.readFile('./test/test.png');
  const optimized = await imgo(buffer, {
    pngquant: true,
    optipng: false,
    zopflipng: false,
    pngcrush: false
  });
  t.true(Buffer.isBuffer(optimized));
  t.true(optimized.length < buffer.length);
});

test('should minify PNG images with optipng', async t => {
  const buffer = await fsP.readFile('./test/test.png');
  const optimized = await imgo(buffer, {
    pngquant: false,
    optipng: true,
    zopflipng: false,
    pngcrush: false
  });
  t.true(Buffer.isBuffer(optimized));
  t.true(optimized.length < buffer.length);
});

test('should minify PNG images with zopflipng', async t => {
  const buffer = await fsP.readFile('./test/test.png');
  const optimized = await imgo(buffer, {
    pngquant: false,
    optipng: false,
    zopflipng: true,
    pngcrush: false
  });
  t.true(Buffer.isBuffer(optimized));
  t.true(optimized.length < buffer.length);
});

test('should minify PNG images with pngcrush', async t => {
  const buffer = await fsP.readFile('./test/test.png');
  const optimized = await imgo(buffer, {
    pngquant: false,
    optipng: false,
    zopflipng: false,
    pngcrush: true
  });
  t.true(Buffer.isBuffer(optimized));
  t.true(optimized.length < buffer.length);
});

test('should not minify PNG images when related options are disabled', async t => {
  const buffer = await fsP.readFile('./test/test.png');
  const optimized = await imgo(buffer, {
    pngquant: false,
    optipng: false,
    zopflipng: false,
    pngcrush: false
  });
  t.true(Buffer.isBuffer(optimized));
  t.true(optimized.length === buffer.length);
});

test('should minify JPG images with jpegRecompress', async t => {
  const buffer = await fsP.readFile('./test/test.jpg');
  const optimized = await imgo(buffer, {
    jpegRecompress: true,
    jpegoptim: false,
    mozjpeg: false
  });
  t.true(Buffer.isBuffer(optimized));
  t.true(optimized.length < buffer.length);
});

test('should minify JPG images with jpegoptim', async t => {
  const buffer = await fsP.readFile('./test/test.jpg');
  const optimized = await imgo(buffer, {
    jpegRecompress: false,
    jpegoptim: true,
    mozjpeg: false
  });
  t.true(Buffer.isBuffer(optimized));
  t.true(optimized.length < buffer.length);
});

test('should minify JPG images with mozjpeg', async t => {
  const buffer = await fsP.readFile('./test/test.jpg');
  const optimized = await imgo(buffer, {
    jpegRecompress: false,
    jpegoptim: false,
    mozjpeg: true
  });
  t.true(Buffer.isBuffer(optimized));
  t.true(optimized.length < buffer.length);
});

test('should not minify JPG images when related options are disabled', async t => {
  const buffer = await fsP.readFile('./test/test.jpg');
  const optimized = await imgo(buffer, {
    jpegRecompress: false,
    jpegoptim: false,
    mozjpeg: false
  });
  t.true(Buffer.isBuffer(optimized));
  t.true(optimized.length === buffer.length);
});

test('should minify GIF images', async t => {
  const buffer = await fsP.readFile('./test/test.gif');
  const optimized = await imgo(buffer, {
    gifsicle: true
  });
  t.true(Buffer.isBuffer(optimized));
  t.true(optimized.length < buffer.length);
});

test('should not minify GIF images when related options are disabled', async t => {
  const buffer = await fsP.readFile('./test/test.gif');
  const optimized = await imgo(buffer, {
    gifsicle: false
  });
  t.true(Buffer.isBuffer(optimized));
  t.true(optimized.length === buffer.length);
});

test('should minify SVG images', async t => {
  const buffer = await fsP.readFile('./test/test.svg');
  const optimized = await imgo(buffer, {
    svgo: true
  });
  t.true(Buffer.isBuffer(optimized));
  t.true(optimized.length < buffer.length);
});

test('should not minify SVG images when related options are disabled', async t => {
  const buffer = await fsP.readFile('./test/test.svg');
  const optimized = await imgo(buffer, {
    svgo: false
  });
  t.true(Buffer.isBuffer(optimized));
  t.true(optimized.length === buffer.length);
});

test('should skip unsupported images', async t => {
  const buffer = await fsP.readFile('./test/test.webp');
  const optimized = await imgo(buffer);
  t.true(Buffer.isBuffer(optimized));
  t.true(optimized.length === buffer.length);
});
