#!/usr/bin/env node

const fs = require('fs');
const path = require('path');
const pify = require('pify');
const globby = require('globby');
const stdin = require('get-stdin');
const minimist = require('minimist');
const filesize = require('filesize');
const chalk = require('chalk');

const imgo = require('.');

const fsP = pify(fs);

const argv = minimist(process.argv.slice(2), {
  alias: {
    h: 'help',
    i: 'info',
    v: 'version',
    j: 'jpg',
    p: 'png',
    g: 'gif',
    s: 'svg'
  }
});

process.stdout.on('error', process.exit);

if (argv.help) {
  fs.createReadStream(path.join(__dirname, '/usage.txt'))
    .pipe(process.stdout)
    .on('close', () => process.exit(1));
} else if (argv.version) {
  console.log(require('./package.json').version);
} else {
  const options = Object.assign({}, argv);
  const names = [];

  if (options.jpg) {
    names.push('mozjpeg', 'jpegoptim', 'jpegRecompress');
  }

  if (options.png) {
    names.push('pngquant', 'pngcrush', 'optipng', 'zopflipng');
  }

  if (options.gif) {
    names.push('gifsicle');
  }

  if (options.svg) {
    names.push('svgo');
  }

  names.forEach(name => {
    options[name] = true;
  });

  if (argv._.length === 0) {
    stdin.buffer()
      .then(buffer => optimize(buffer, options, argv.info))
      .then(buffer => process.stdout.write(buffer));
  } else {
    globby(argv._, {nodir: true}).then(paths => {
      return Promise.all(paths.map(p => {
        return fsP.readFile(p)
          .then(b => optimize(b, options, argv.info))
          .then(b => fsP.writeFile(p, b));
      }));
    });
  }
}

function optimize(buffer, options, info) {
  const before = buffer.length;
  let after = 0;

  return imgo(buffer, options)
    .then(b => {
      after = b.length;

      if (info) {
        console.error(
          chalk.gray(' before=') + chalk.yellow(filesize(before)) +
          chalk.gray(' after=') + chalk.cyan(filesize(after)) +
          chalk.gray(' reduced=') + chalk.green.underline(filesize(after - before))
        );
      }

      return b;
    });
}
